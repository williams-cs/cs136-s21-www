<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../resources/cs136.css" type="text/css">
    <title>CSCI 136</title>
  </head>

  <body>

    <!-- standard header (found in header.html) -->
    <p class="title2"><font size="5">CSCI 136 :: Spring 2021</font></p>
    <p class="title">Data Structures &amp; Advanced Programming</p>
    <p class="box">
      <a href="../index.html">Home</a> |
      <a href="../schedule.html">Schedule</a> |
      <a href="../labs.html">Labs</a> |
      <a href="../handouts.html">Handouts</a> |
      <a href="../links.html">Links</a> |
      <a href="https://csci.williams.edu/">CS@Williams</a>
    </p>

    <p class="heading">Lab 9: Spot the Difference</p>

    <p class="info">
	Up until this point in class, we've been using <tt>git</tt> to submit assignments.  You may have wondered what exactly gets sent to the server when you run <tt>git push</tt>.  If you make one change, is the entire file reuploaded?  It would be much more efficient if, instead, <tt>git</tt> could calculate what changes were made to the file, and only upload those changes to the server.  In fact, git does make this calculation!<BR><BR>
	&nbsp;
	&nbsp;
	&nbsp;
	Our goal in this lab is to create a Java program that does exactly this: given two files (an old version and a new version of the file), calculate the minimum number of changes required to transform the old version into the new version of the file.
	</p>

    <p class="heading">What's the Difference?</p>
	<p class="text">
	Our goal is to list the differences between the two files on a line by line basis:  
	</p>
	<ul class="bullet"> 
		<li> If a line was not included in the old version of the file, but is included in the new version, it should be prefixed by <tt>&gt;</tt> and its line number.
		<li> On the other hand, if a line was in the old version, but has been removed in the new version, it should be prefixed by <tt>&lt;</tt> and its line number.  </li>
		<li> If a line stays the same between the two versions, it should not be included in the output.</li>
	</ul>
	<p class="text">
	For example, let's say the old version of our file is:
	</p>
	<pre class="text">
match
onlyA</pre>
	<p class="text">
	and the new version is:
	</p>
	<pre class="text">
match
onlyB</pre>
	<p class="text">
	Then the output should be:
	</p>
	<pre class="text">
 &lt; 2: onlyA
 &gt; 2: onlyB
	</pre>
	<p class="text">
	This calculation is quite similar to the output of the unix utility <tt>diff</tt>.  You can try running 
	<pre class="text">
	% diff sample/verySmallA sample/verySmallB
	</pre>
	<p class="text">
	and you will see a similar output.  Paying homage to this utility, we'll call our result the <tt>diff</tt> of two files.
	</p>

	<p class="heading">Calculating the Optimal Differences</p>
    <p class="text">
	In this lab, we want to calculate the <i>minimum</i> sequence of differences between the old and new version of the file.  How can we make sure that the differences we output are, in fact, the minimum?  To ensure an optimal solution, we fall back to a classic technique in the course: we brute force all possibilities using recursion.

	Let's say we have two files <tt>file1</tt> and <tt>file2</tt>, each stored as Strings.
	To start, there are two possibilities to obtain the minimum difference between these files:
	</p>
	<ul class="bullet">
	<li> It may be that the minimum difference is obtained by deleting the first line of <tt>file1</tt>.  Then the minimum number of differences is 1 plus the minimum number of differences between the remainder of <tt>file1</tt> (with the first line deleted), and <tt>file2</tt>.  In this case, the solution begins with the first line of <tt>file1</tt>, with <tt>&lt;</tt> and the line number prepended, and continues with the recursive solution.</li>
	<li> On the other hand, perhaps the minimum difference involves deleting the first line from <tt>file2</tt>.  Then the minimum number of differences is 1 plus the minimum number of differences between <tt>file1</tt>, and the remainder of <tt>file2</tt> (with the first line deleted).  In this case, the solution begins with the first line of <tt>file2</tt>, with <tt>&gt;</tt> and the line number prepended, and continues with the recursive solution. </li>
	</ul>
    <p class="text">
	If the first lines of file 1 and file 2 are the same, then we have a third option:
	</p>
	<ul class="bullet">
		<li> Perhaps the first line of <tt>file1</tt> should remain unchanged in <tt>file2</tt>.  Then the minimum number of differences is the minimum number of differences between the remainder of <tt>file1</tt> and <tt>file2</tt> (with one line deleted from each).  
	</ul>
    <p class="text">
	For any pair of files, we have either 2 or 3 possibilities for how to proceed.  We calculate the cost of each recursively.  We take the choice that gives the minimum cost, and return that as our solution.
	</p>
	<p class="text">
	Finally, any recursive algorithm needs a base case.  If <tt>file1</tt> is empty, then the remaining difference consists of all of <tt>file2</tt>, with the <tt>&gt;</tt> character and line number prepended to each line.  Similarly, if <tt>file2</tt> is empty, then the remaining difference consists of all of <tt>file1</tt>, with the <tt>&lt;</tt> character and line number prepended to each line.
	</p>
	
    <p class="heading">Simplifying the Design</p>
	<p class="text">
	As-is, this approach is a bit difficult to work with: we need to spend lots of work splitting the first line off of each file.  This is inefficient, and it would significantly clutter up our code.
	Instead, let's split each file into a <tt>Vector</tt> of <tt>String</tt>s, where each entry is a line of the file.  
	</p>
	<p class="text">
	With this change, we can recurse by keeping track of which lines remain in each file.  
	To recurse, we'll use a helper method:
	</p>
	<p class="text">
	<code>
			public Association&lt;Integer, String&gt; diffHelper(int remainingFile1Index, int remainingFile2Index)
	</code>
	</p>
    <p class="text">
	<tt>diffHelper</tt> finds the optimal diff between the suffix of <tt>file1</tt> starting at line <tt>remainingFile1Index</tt>, and the suffix of <tt>file2</tt> starting at line <tt>remainingFile2Index</tt>.
	It returns an <tt>Association</tt> between an <tt>int</tt> (representing the cost of the solution), and a <tt>String</tt> (representing the actual diff to return).
	</p>
    <p class="text">
	<tt>diffHelper</tt> works recursively as described above. We can determine if <tt>diffHelper</tt> is in a base case (where one of the files is empty) by comparing <tt>remainingFile1Index</tt> and <tt>remainingFile2Index</tt> to the size of each vector.  
		If both files are nonempty, <tt>diffHelper</tt> considers two or three possibilities, each calculated with a recursive call.  The first two recursive calls remove one line from <tt>file1</tt> and <tt>file2</tt>; these recursive calls can be made by modifying <tt>remainingFile1Index</tt> and <tt>remainingFile2Index</tt> respectively.
	</p>
    <p class="heading">Task 1: Implement The Difference Algorithm</p>
	<p class="text">
	Your first task is to implement <tt>diffHelper</tt> using the recursive method described above, in the file <tt>Diff.java</tt>.  You should store the files using a <tt>Vector&lt;String&gt;</tt> to simplify your design (this has already been implemented in the starter code).  You will probably want to use helper methods to keep your <tt>diffHelper</tt> method short.   You don't need to use any other class yet; task 1 can be completed by only modifying <tt>Diff.java</tt>.
	</p>
	<p class="text">
	First, implement the base case, where one of the files has no remaining lines.  You may want to use a helper function for the base case.  After the base case is implemented, <tt>Diff</tt> should work correctly when one of the files is empty.  In particular, if you run the command 
	</p>
	<pre class="text">
		% java Diff samples/verySmallA.txt samples/empty.txt
	</pre>
	<p class="text">
	then the result you obtain should exactly match the sample solution in <tt>emptySolution.txt</tt>.  This is a good opportunity to make sure the format of your output matches the expected format---make sure the output matches before you proceed further in the lab.
	</p>
	<p class="text">
	Next, implement the recursive algorithm.  
	In some cases, there may be multiple optimal solutions.  <b>Make sure you break ties according to the following rules</b> so that your output matches the sample output:
	</p>
	<ul class="bullet">
		<li> If matching lines leads to an optimal solution, then return the solution with matching lines.</li>
		<li> Otherwise, if deleting a line from <tt>file1</tt> leads to the same cost as deleting a line from <tt>file2</tt>, return the solution that deletes a line from <tt>file1</tt>.
	</ul>
	
    <p class="text">
	   After implementing <tt>diffHelper</tt>, your java program should run successfully on the inputs <tt>verySmallA.txt</tt> and <tt>verySmallB.txt</tt> (matching the output in <tt>verySmallSolution.txt</tt>), as well as <tt>smallA.txt</tt> and <tt>smallB.txt</tt> (matching the output in <tt>smallSolution.txt</tt>).  It will also run correctly on the other sample files, but the time it takes will be prohibitively large.
	</p>
    <p class="heading">Improving Efficiency</p>
    <p class="text">
	The recursive algorithm described above is very slow.  In fact, if <tt>file1</tt> and <tt>file2</tt> have <i>n</i> and <i>m</i> lines respectively, then this algorithm takes <i>Ω(2^(n+m))</i> time.
	</p>
	<p class="text">
	Part of the reason this algorithm is so slow is due to <tt>diffHelper</tt> computing the same thing over and over.  Each new recursive call to <tt>diffHelper</tt> requires an entire, possibly slow computation&mdash;even if an identical call was made in the past.
	</p>
	<p class="text">
	We need a way to keep track of previous calls to <tt>diffHelper</tt>.  If <tt>diffHelper</tt> is called a second time with the same arguments, rather than recomputing the solution from scratch, we want to look up the solution calculated last time it was called.  Then, we can return it immediately.
	</p>
	<p class="text">
	We need a few things to accomplish this.  First, we need a way to keep track of which calls have been made to <tt>diffHelper</tt>.  Since <tt>diffHelper</tt> takes two <tt>int</tt>s as arguments, let's create a class <tt>IntPair</tt> that stores two <tt>int</tt>s.  
	</p>
	<p class="text">
	Then, we want to store, for each <tt>diffHelper</tt> we have called in the past, the final return value of the method (which is an <tt>Association&lt;Integer, String&gt;</tt>).  We want to be able to lookup if we've made a call with a given <tt>IntPair</tt> in the past, and if so, find the associated <tt>Association</tt> and return it.  Otherwise, at the end of <tt>diffHelper</tt>, we want to keep track of  the <tt>IntPair</tt> and the newly calculated return value.
	</p>
	<p class="text">
	This is an ideal situation for hashing.  
	At the beginning of a recursive call, we <tt>get</tt> an <tt>IntPair</tt> consisting of <tt>remainingFile1Index</tt> and <tt>remainingFile2Index</tt> to see if their final value has been previously caluclated.  If so, we return it.  Otherwise, after completing a new recursive call, we want to <tt>put</tt> the arguments along with the calculated return value into the hash table.  
	</p>

    <p class="heading">Task 2: Speed Up Diff With Hashing</p>
	<p class="text">
	Implement a version of <tt>diffHelper</tt> that uses a hash table to avoid repeated calculations in <tt>HashDiff.java</tt>.  The <tt>HashDiff</tt> class extends the <tt>Diff</tt> class, so you will have access to all of the variables and methods you already wrote in task 1.  You should use your <tt>diffHelper</tt> from <tt>Diff</tt> as a staring point, incorporating the hashtable checks described above. <b> Make sure your diffHelper method works correctly before starting task 2!</b>  Otherwise, if you made a mistake in your original implementation, you'll need to fix it in two places.

		<p class="text">
		You'll need to create an <tt>IntPair</tt> class (much of it is already implemented in the starter code).  Don't forget to create a <tt>hashCode()</tt> method for <tt>IntPair</tt> so that it can be used as a key in a hash table.  The <tt>hashCode()</tt> method of <tt>IntPair</tt> should return the sum of the integers stored in <tt>IntPair</tt>.
	</p>
	<p class="text">
	Once this is completed, <tt>HashDiff</tt> should be able to correctly diff <tt>maSenate2016.txt</tt> and <tt>maSenate2020.txt</tt> in a few seconds.  Your solution should match <tt>maSenateSol.txt</tt>.
	</p>
	<pre class="text">
		% java HashDiff samples/maSenate2016.txt samples/maSenate2020.txt
	</pre>

    <p class="heading">Task 3: Getting a Better Hash Function</p>
	<p class="text">
	Unfortunately, the hash described above has suboptimal performance: many pairs share the same hash code.  For example, if <tt>remainingFile1Index</tt> is 3, and <tt>remainingFile2Index</tt> is 1, we'll get the same hash code as when <tt>remainingFile1Index</tt> is 2 and <tt>remainingFile2Index</tt> is 2.
	</p>
	<p class="text">
	As a result, you may find that your program still cannot compute the <tt>diff</tt> of <tt>whosonfirst.txt</tt> and <tt>whosonfirst2.txt</tt> in a reasonable time.  (It takes just over 15 minutes on my machine.)
	</p>
	<p class="text">
	To speed up execution, implement the following <tt>hashCode()</tt> method  in the <tt>BetterIntPair</tt> class (<tt>BetterIntPair</tt> extends <tt>IntPair</tt>, so you only need to override the <tt>hashCode()</tt> method).  The instance variables used in this method are already included in the starter code.
	</p>
	<pre class="text">
		return ((hashMult * int1 + hashAdd) % hashPrime) +
				((hashMult * int2 + hashAdd) % hashPrime);
	</pre>
	<p class="text">
	Multiplying by a large random number, adding a second large random number, and finally taking the result modulo a large random prime is one of the best-known methods for hashing integers (or, in this case, pairs of integers).  And it should work particularly well here.  
</p>
<p class="text">
Create a new implementation of <tt>diffHelper()</tt> in <tt>BetterHashDiff.java</tt> that uses the <tt>BetterIntPair</tt> class in the hash table.  This implementation will likely be very similar to the version of <tt>diffHelper()</tt> implemented in <tt>HashDiff.java</tt>.
With this improvement, <tt>BetterHashDiff</tt> should be able to quickly and correctly calculate the diff for all sample files.  In particular, <tt>BetterHashDiff</tt> should be able to quickly calculate the diff of <tt>whosonfirst.txt</tt> and <tt>whosonfirst2.txt</tt>, obtaining a solution matching <tt>whosonfirstSol.txt</tt>
	</p>
	<pre class="text">
		% java BetterHashDiff samples/whosonfirst.txt samples/whosonfirst2.txt
	</pre>
    <p class="heading">Task 4: Thought Questions</p>
	<p class="text">
	Answer the following questions in <tt>PROBLEMS.md</tt>.
		<ul class="bullet">
			<li>This question is about the reason why the more complex hash function in Task 3 led to a significant speedup over the simpler hash function in Task 2.  Let's say that throughout all recursive calls, <tt>remainingFile1Index</tt> is always between 0 and <i>n-1</i>, and <tt>remainingFile2Index</tt> is always between 0 and <i>m-1</i>. 
				<ul class="bullet">
					<li> In this case, how many possible <tt>IntPair</tt>s can there be throughout the execution of the program?</li>
					<li>   How many possible <tt>hashCode</tt>s can be output by all <tt>IntPair</tt>s?  <i>(Hint: What is the maximum value that can be output by <tt>hashCode()</tt>?  What is the minimum value?)  </i></li>
				</ul></li>
			<li> Rather than using an <tt>IntPair</tt> in this lab, we could have used an <tt>Association&lt;Integer, Integer&gt;</tt>.  What would be the downside of doing this?
		</ul>
	</p>



    <p class="heading">Pre-lab</p>
    <p class="text">
		Before lab, please do the following:

		<ul class="bullet">
			<li>
				In this lab, the amount of code you write won't be too large, but the concepts behind the lab are fairly new.  For this reason, be sure to carefully read through the lab description before you get started.
			</li>
		</ul>
    </p>


    <p class="heading" id="checkstyle">
      <strong><code>checkstyle</code> requirements</strong>:
    </p>

    <p class="text">
      For this lab, we will be not be adding any
      new <code>checkstyle</code> rules to the set of rules that we
      have used in previous weeks.
    </p>

    <p class="text">
      We <em>STRONGLY ENCOURAGE</em> you to run
      checkstyle early and often when developing your code,
      and try to program in a way that minimizes WARNING messages.
      The checkstyle rules that we use in this course
      are based on real-world style guides;
      internalizing good style practices will help us write more
      readable code.
    </p>

    <p class="text">
      <b>In total, checkstyle will enforce the following guidelines:</b>
    </p>

    <ul class="bullet">
      <li>
	All class variables that are not <code>final</code> must be
	declared <code>private</code> or <code>protected</code> (i.e.,
	no <code>public</code> member variables unless they are
	constants). (We don't expect this to be an issue this week.)
      </li>

      <li>
	All <code>public</code> methods must include a “Javadoc” comment
	(starts with <code>/**</code> and ends with <code>*/</code>;
	it should include descriptions of the function at the top,
	descriptions of return values after a <code>@return</code> tag,
	descriptions of each argument after a <code>@param</code> tag,
	and pre/post conditions after the <code>@pre</code>
	or <code>@post</code> tags).
      </li>
      <li>
	No methods should be longer than 30 lines (excluding
	whitespace and single-line comments).
      </li>
    </ul>


    <br><br>

    <p class="text">
      <b>To run <code>checkstyle</code>, you would type the following
      command at the terminal:</b>
    </p>

    <pre><code>
          $ ./checkstyle
        </code></pre>

    <p class="text">
      The <code>./</code> is peculiar to Unix: it tells the terminal
      to look for the <code>checkstyle</code> program in the current
      directory.  This command will run <code>checkstyle</code> on
      every Java program in your directory.  To
      run <code>checkstyle</code> on a specific Java file, type:
    </p>

    <pre><code>
          $ ./checkstyle SomeFile.java
    </code></pre>


    <p class="heading">Lab Deliverables</p>
    <p class="text">
      For this lab, please submit the following:
    </p>
      <ul class="bullet">
	<li>
          Your well-documented source code in <tt>Diff.java</tt> and <tt>IntPair.java</tt>.
	</li>
<li>
	  The <tt>PROBLEMS.md</tt> file that contains answers to the
	  questions described above, as well as any other information
	  about your submission.
	</li>
      </ul>
    <p class="text">
      As in all labs, you will be graded on design, documentation, style,
      and correctness.
      Be sure to document your program with appropriate comments,
      including a general description at the top of each Java class,
      a description of each method with pre- and post-conditions where
      appropriate.
      Also use comments and descriptive variable names to clarify sections
      of the code which may not be clear to someone trying to understand it.
    </p>

    <p class="heading">Submitting Your Lab</p>
    <p class="text">
      As you complete various milestones,
      you should <tt>commit</tt> your changes and <tt>push</tt> them.
      <b>Commit early and often</b>.
      When the deadline arrives,
      we will retrieve the latest version of your code.
      If you are confident that you are done,
      please include "Lab Submission" as the commit message for your final commit.
      If you later decide that you have more edits to make, it is OK.
      We will look at the latest commit before the deadline.
    </p>
    <ul class="bullet">
      <li><b>Be sure to push your changes to GitLab</b>
      </li>

      <li><b>Verify your changes on GitLab</b>.
	Navigate in your web browser to your private repository on GitLab.
	You should see all changes reflected in the various files that you submit.
	If not, go back and make sure you committed <em>and</em> pushed.
      </li>
    </ul>

    <p class="text">
      We will know that the files are yours because they are in <em>your</em>
      git repository.
      Do not include identifying information in the code that you submit.
      Our goal is to grade the programs anonymously to avoid any bias.
      However, in your <tt>README.md</tt> file,
      please cite any sources of inspiration or collaboration
      (e.g., conversations with classmates).
      We take the honor code very seriously, and so should you.
      Please include the statement
      "I am the sole author of the work in this repository"
      in the comments at the top each of your java files.
    </p>
  <p class="bottom">&nbsp;</p>
  </body>
</html>
