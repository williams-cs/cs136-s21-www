<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../resources/cs136.css" type="text/css">
    <title>CSCI 136</title>
  </head>

  <body>

    <!-- standard header (found in header.html) -->
    <p class="title2"><font size="5">CSCI 136 :: Spring 2021</font></p>
    <p class="title">Data Structures &amp; Advanced Programming</p>
    <p class="box">
      <a href="../index.html">Home</a> |
      <a href="../schedule.html">Schedule</a> |
      <a href="../labs.html">Labs</a> |
      <a href="../handouts.html">Handouts</a> |
      <a href="../links.html">Links</a> |
      <a href="https://csci.williams.edu/">CS@Williams</a>
    </p>

    <p class="heading">Recursion, Recursion, Recursion, ...</p>

    <p class="info">
       We love recursion.
       Recursion is a powerful design technique, but
       it can be a difficult concept to master,
       and it is worth concentrating on in isolation before using in
       large programs.
       Thus,
       this week's lab is structured as several small problems that can be
       solved separately from one another&mdash;although we suggest you work on them in the order given!

       <br><br>

       The goals of this lab are to:<br>
       &bull; Practice writing recursive programs.<br>
       &bull; Solve a variety of interesting algorithmic problems.<br>
       &bull; Train your brain to think recursively.

       <br><br>

       Recursive solutions can often be formulated in just a few concise,
       elegant lines,
       but they can be very subtle and hard to get right.
       A small error in a recursive method gets magnified by the many recursive
       calls and so an incorrect method can have somewhat surprising behavior.
       Although each problem will have a fairly short solution,
       it may take you a while to find it&mdash;give it time!
    </p>

    <p class="heading">A Note on Working With a Partner</p>
    <p class="text">
      There are multiple approaches for carrying out a programming assignment
      with a partner. In this course, the purpose is to provide the opportunity
      for two students to work jointly to develop and implement algorithms
      for solving problems. <b>This is the approach we require partners to follow.</b>
    </p>
    <p class="text">
      In particular, we prohibit partners from taking the approach of "dividing
      up the work" and then working separately on their individual "subprojects".
      If you have questions about this requirement, please ask us!
    </p>

    <p class="heading">The Tao of Recursion</p>
    <p class="text">
      Take time to figure out how each problem is recursive in nature
      and how you
      could formulate the solution to the problem if you already had the
      solution to a smaller, simpler version of the same problem. You will
      need to depend on a recursive "leap of faith" to write the solution in
      terms of a problem you haven't solved yet. Be sure to take care of
      your base case(s) lest you end up in infinite recursion&mdash;which can
      have somewhat spectacular (not in the good way) results....
    </p>
    <p class="text">
      Also, as you'll see below, sometimes a method signature doesn't provide the
        right number or types of parameters to allow us to directly implement it recursively.
        In such situations we have that method call a recursive <i>helper</i> method,
        for which we can choose the most appropriate set of parameters. Note: this
        situation frequently arises when another party has specified the method
        signature in advance (welcome to the real world).
    </p>
    <p class="text">
      The great thing about recursion is that once you learn to think
      recursively, recursive solutions to problems seem very intuitive.
      (Did we mention that we love recursion...?)
      Spend some time on these problems and you'll be much better prepared
      when you are faced with more sophisticated recursive problems in
      the wild.
    </p>
    <p class="heading">PRE-LAB Step 0: Warm-up Problems</p>
    <p class="text">
      Given the structure of this lab, a full design document is not
      required this week.
      However, as always, you should  read through the lab carefully
      and think about how you will structure your solutions.
      If possible, sketch a written
      design for the warm-up problems described below,
      and bring it to lab.
      <br><br>
      Brainstorming can be very useful when learning to think recursively.
      This is why we encourage you to work with a partner in lab this week,
      if you'd like.
      You can work on the <b>Prelab warm-up problems</b> before lab with a larger group,
      <b>even if you do not work with that group during the rest of the lab</b>.
      Since the PRE-LAB problems will not be graded, you may discuss code, logic,
      and anything else (about those problems only) with your classmates.
    </p>

    <p class="heading">PRE-LAB Warmup Problem 0.1: Digit Sum</p>
    <p class="text">
      Write a recursive method <code>digitSum</code>
      that takes a non-negative integer and returns the sum of its digits.
      For example, <code>digitSum(1234)</code>
      returns <code>1 + 2 + 3 + 4 = 10</code>.
      Your method should take advantage of
      the fact that it is easy to break a number into two smaller pieces by
      dividing by 10. Recall that integer division truncates (e.g., <code>1234/10 = 123</code>)
      and the mod operation yields the remainder (e.g., <code>1234%10 = 4</code>).
      <br><br>
      For these methods, we do not need to construct any objects.
      Therefore, you can declare them to be <code>static</code> methods
      and call them
      directly from <code>main</code>:
    </p>
      <pre><code>
            public static int digitSum(int n) { ... }
      </code></pre>



    <p class="heading" id="canmakesum">PRE-LAB Warmup Problem 0.2: Subset Sum</p>
    <p class="text">
      Subset Sum is an important and classic problem in computer science.
      Given a set of integers and a target number, your goal is to
      find a subset of those numbers that sum to the target number.
      For example, given the set <code>{3, 7, 1, 8, -3}</code>
      and the target sum <code>4</code>,
      the subset <code>{3, 1}</code> sums to <code>4</code>.
      On the other hand, if the target sum were <code>2</code>,
      we have a problem: there is no subset that sums
      to <code>2</code>. For this warm-up problem, we do not ask
      you to identify any particular subset;
      instead, we want you to return <code>true</code>
      if there exist one or more subsets that sum to the target number,
      and false otherwise.
      The prototype for this method is:
      <pre><code>
            public static boolean canMakeSum(int setOfNums[], int targetSum)
      </code></pre>
    </p>
    <p class="text">
      Assume that the array contains <code>setOfNums.length</code> numbers
      (i.e., it is completely full).
      Note that you are not asked to print the subset members,
      just return <code>true</code> or <code>false</code>.
      You will likely need a helper method to pass additional information
      through the recursive calls.
      What additional information would be useful to track?
    </p>

    <p class="text">
      By the way, no one has yet discovered an efficient algorithm to solve this problem,
      where efficient means "runs in O(p(n)) time for some polynomial p(n))". If you are
      the first to do so, the <a href="https://www.claymath.org/millennium-problems/millennium-prize-problems">
        Clay Mathematics Institute</a> will pay you $1,000,000.
        Even an algorithm that runs in O(n<sup>1000</sup>) time would qualify! Just sayin'....
    <p class="heading" id="step0">Lab Programs</p>
    <p class="text">
      For each problem below, you must thoroughly test your code to
      verify it correctly handles all reasonable cases.
      For example, for
      the "Digit Sum" warm-up, you could use test code to call your method
      in a loop to allow the user to
      repeatedly enter numbers that are fed to your method until you are
      satisfied.
      Testing is necessary to be sure you have handled all the
      different cases. You can leave your testing code in the file you
      submit&mdash;there is no need to remove it.<BR>

      For each exercise, we specify the method signature.  <b>Your method must
        exactly match that prototype</b> (same name, same arguments, and same
      return type).  You may need to add additional helper methods for some of
      these questions; these functions may have different arguments but must
      have the same return type. <b>Your solutions must be recursive and contain no loops,</b> even
      if you can come up with an iterative alternative.  </p>




    <p class="heading" id="step0">Problem 1: Counting Cannonballs</p>
    <p class="text">
      Spherical objects, such as cannonballs, can be stacked to form a
      pyramid with one cannonball at the top, sitting on top of a square
      composed of four cannonballs, sitting on top of a square composed of
      nine cannonballs, sitting on top of a square composed of sixteen cannonballs,
      and so forth.  Write a recursive method
      <code>countCannonballs</code> that takes as its argument the height of a
      pyramid of cannonballs and returns the number of cannonballs it
      contains.
      The prototype for the method should be as follows:
      <pre><code>
            public static int countCannonballs(int height)
      </code></pre>

    <p class="text">
      <b>Note:</b> Are there any pre-conditions to <code>countCannonBalls(int
      height)</code>?  <b>For any of the <code>public</code> methods that
      have preconditions or postconditions, please document those in
      your comments, and check with an assertion.</b>
    </p>
    </p>

    <p class="heading">Problem 2: Palindromes</p>
    <p class="text">
      Write a recursive method <code>isPalindrome</code> that takes a string and
      returns true if it is the same when read forwards or backwards.
      For example,
    </p>
      <pre>
	isPalindrome("mom")   &rarr; true
	isPalindrome("cat")   &rarr; false
	isPalindrome("level") &rarr; true
      </pre>

    <p class="text">
      The prototype for the method should be as follows:
      <pre><code>
            public static boolean isPalindrome(String str)
      </code></pre>
    </p>
    <p class="text">
    You may assume the input string contains no spaces.<br><br>
    </p>
    <p class="text">
      <b>Special cases:</b> Is the empty string a palindrome?
      Does capitalization matter (e.g., is "<tt>Dad</tt>" a palindrome?).
      Please document your choice(s) in your comments so it is clear how your
      program is expected to behave.
    </p>



    <p class="heading">Problem 3: Balancing Parentheses</p>
    <p class="text">
      In the syntax of most programming languages, there are characters that
      occur only in nested pairs, called bracketing operators.
      Java, for example, has these bracketing operators:
    </p>
    <pre>
            ( . . . )
            [ . . . ]
            { . . . }
    </pre>
    <p class="text">
      In a properly formed program,
      these characters will be properly "nested" and "matched".
      To determine
      whether this condition holds for a particular program,
      you can ignore all the other characters and look simply at
      the pattern formed by the parentheses, brackets, and braces.
      In a legal configuration,
      all the operators match up correctly,
      as shown in the following example:
      <pre>
            { ( [ ] ) ( [ ( ) ] ) }
      </pre>
      <p class="text">
      The following configurations, however,
      are illegal for the reasons stated:
      </p>
      <pre>
	( ( [ ] )      &rarr; The line is missing a close parenthesis.
	) (            &rarr; The close parenthesis comes before the open parenthesis.
	{ ( } )        &rarr; The parentheses and braces are improperly nested.
      </pre>

    <p class="text">
      Write a recursive method
    </p>
      <pre><code>
            public static boolean isBalanced(String str)
      </code></pre>
    <p class="text">
      that takes a string <code>str</code> from which all characters
      except the bracketing operators have been removed (precondition?).
      The method should return <code>true</code> if the bracketing operators
      in <code>str</code> are <em>balanced</em>,
      which means that they are correctly nested and matched.
      If the string is not balanced,
      the method returns <code>false</code>.
    </p>
    <p class="text">
      Although there are many other ways to implement this operation,
      you should code your solution so that it embodies
      the recursive insight that a string consisting only of bracketing
      characters is balanced if and only if
      one of the following conditions holds:
    </p>
      <ul class="bullet">
	<li>
	  The string is empty.
	</li>
	<li>
	  The string contains "<code>()</code>", "<code>[]</code>", or "<code>{}</code>"
	  as a substring and is still balanced if you remove that substring.
	</li>
      </ul>
    <p class="text">
      For example, the string "<code>[(){}]</code>" is shown to be balanced
      by the following chain of calls:
    </p>

    <pre>
          isBalanced("[(){}]")   &rarr;
            isBalanced("[{}]")   &rarr;
              isBalanced("[]")   &rarr;
                isBalanced("")   &rarr; true
    </pre>

    <p class="text">
      <b>Hint</b>: Using the above example, can you reason backwards
      about how the code might be structured?
    </p>


    <p class="heading">Problem 4: Subsequences</p>
    <p class="text">
      Write a method:
    </p>
    <pre><code>
            public static void subsequences(String str)
    </code></pre>
    <p class="text">
      that prints out all <a href="https://en.wikipedia.org/wiki/Subsequence">subsequences</a>
      of the letters in <code>str</code>.
      For example:
    </p>
<pre>
           substring("ABC") &rarr; "", "A", "B", "C", "AB", "AC", "BC", "ABC"
</pre>

    <p class="text">
      The order that you print them does not matter.
      You may find it useful to write a helper method, such as:
    </p>
    <pre><code>
            protected static void subseqHelper(String str, String soFar)
    </code></pre>
    <p class="text">
      In our implementation, this helper is initially called as <code>subseqHelper(str, "")</code>.
      We use the variable <code>soFar</code> to keep track of the characters that currently
      in the subsequence we are building.
    </p>
    <p class="text">
      To process <code>str</code> you must:
    </p>
  <ul class="bullet">
    <li>
      build all subsequences containing the first character
      (which you do by including that character in <code>soFar</code>), and
    </li>
    <li>
      build all subsequences not including the first character (leaving <code>soFar</code> unchanged).
    </li>
  </ul>
  <p class="text">
  Continue until <code>str</code> has no more characters in it.
  </p>

    <p class="heading">Problem 5: Print In Binary</p>
    <p class="text">
      Although we are used to referring to numbers in decimal
      computers represent integers as sequences of bits.
      A bit is a single digit in the binary number system
      and can therefore have only the value <code>0</code> or <code>1</code>.
      The table below shows the first few integers represented
      in binary:
    </p>
    <pre>
          binary | decimal
          -------|--------
               0 | 0
               1 | 1
              10 | 2
              11 | 3
             100 | 4
             101 | 5
             110 | 6
    </pre>

        <p class="text">
	  Each entry in the left side of the table is written in its standard
	  binary representation, in which each bit position counts for twice as
	  much as the position to its right. For instance, you can demonstrate
	  that the binary value <code>110</code> represents the decimal number <code>6</code> by following
	  this logic:
	</p>
	<pre>
          place value   &rarr; 4   2   1
                          ×   ×   ×
          binary digits &rarr; 1   1   0
                          &darr;   &darr;   &darr;
                          4 + 2 + 0 = 6
	</pre>
    <p class="text">
      Basically, this is a base-2 number system instead of the decimal
      (base-10) system we are familiar with. Write a recursive method
    </p>
    <pre><code>
          public static void printInBinary(int number)
    </code></pre>
    <p class="text">
      that prints the binary representation for a given integer. For
      example, calling <code>printInBinary(3)</code>
      would print <code>11</code>, and <code>printInBinary(42)</code>
      would print <code>101010</code>.
      Your method may assume the integer parameter is always non-negative (precondition?).
    </p>
    <p class="text">
      <b>Hint</b>:
      You can identify the least significant binary digit by using the
      modulus operator with value 2 (i.e., <code>number % 2</code>).
      For example, given the integer 35,
      the value <code>35 % 2 = 1</code> tells you that the last
      binary digit must be <code>1</code>
      (i.e., this number is odd),
      and division by <code>2</code>
      gives you the remaining portion of the integer (<code>17</code>).
      <br><br>
      <b>Hint</b>: You will probably want to use the method
      <code>System.out.print</code> in the problem.
      It is just like <code>System.out.println</code>,
      but does not follow the output with a new line.
    </p>

    <p class="heading">Problem 6: Extending Subset Sum</p>
    <p class="text">
      For the last problem, you are to write two modified versions of the <code>canMakeSum</code>
       <a href="#canmakesum">PRE-LAB problem</a>:
    </p>
    <ul class="bullet">
      <li>Rather than returning <code>true</code> or <code>false</code>,
	change the method to print the members in a successful subset if
	one is found.
	You should do this without adding any new data structures
	(i.e. don't build a second array to hold the subset).
	Instead, use the "unwind" of the recursive calls.</li>
    </ul>
    <pre><code>
                public static boolean printSubsetSum(int nums[], int targetSum)
    </code></pre>

    <ul class="bullet">
      <li>Rather than returning <code>true</code> or <code>false</code>,
	change the method so that it returns
	the total number of all possible subsets.
	For example, in the set shown <a href="#canmakesum">earlier</a>,
	the subset <code>{7, -3}</code>
	also sums to <code>4</code>, so there are
	two possible subsets for the target value <code>4</code> (i.e., <code>{3, 1}</code> and <code>{7, -3}</code>).
	<br>
	In this method, you <em>do not need to print all of the subsets</em>, only return the number of subsets.
      </li>
      </ul>
	<pre><code>
                public static int countSubsetSumSolutions(int nums[], int targetSum)
	</code></pre>
<!--
<li>
  <b>Optional Bonus Part</b>: Change the method to print <em>all</em> subsets that sum to <code>targetSum</code>.
</li>
-->
<!--
    <p class="heading">Optional Problem: Cell Phone Mind Reading</p>
    <p class="text">
    Entering text using the digit keys on a phone is problematic, in that
    there are only 10 digits for 26 letters and thus each digit key is
    mapped to several letters. Some cell phones require you to "multitap":
    tap the 2 key once for 'a', twice for 'b' and three times for 'c',
    which gets tedious.
    </p>
    <p class="text">
    Technology like Tegic's T9 predictive text allows the user to press
    each digit key once and based on the user's sequence so far, it
    guesses which letters were intended, having found the possible
    completions for the sequence. For example, if the user types the digit
    sequence "72", there are nine possible mappings (pa, pb, pc, ra, rb,
    rc, sa, sb, sc). Three of these mappings seem promising (pa, ra, sa)
    because they are prefixes of words such as "party" and "sandwich",
    while the other mappings can be ignored since they lead nowhere. If
    the user enters "9956", there are 81 possible mappings, but you can be
    assured the user meant "xylo" since that is the only mapping that is a
    prefix of any English words.
    </p>
    <p class="text">
    You are to implement an algorithm to find the possible completions for
    a digit sequence. The <code>listCompletions</code> method is given the user's
    digit sequence and a <code>Lexicon</code> object. The method will print all
    English words that can be formed by extending that
    sequence. For example, here is the list of completions for "72547": <BR><BR>
    <tt>
      palisade<BR>
    palisaded<BR>
    palisades<BR>
    palisading<BR>
    palish<BR>
    rakis<BR>
    rakish<BR>
    rakishly<BR>
    rakishness<BR>
    sakis<BR><BR>
    </tt>
    We will provide a <code>Lexicon</code> class that serves as a dictionary of
English words for you to use.  Your recursive method will take the
lexicon as a parameter.  Here are the important parts of the lexicon
interface:
<pre><code>
        public class Lexicon {
          /**
           * Loads a lexicon from the specified file.
           */
          public Lexicon(String fileName)

          /**
           * Returns true if the word is contained in the lexicon.
           */
          public boolean contains(String word)

          /**
           * This method returns true if any words in the lexicon begin with the
           * specified prefix, false otherwise. A word is defined to be a prefix of
           * itself and the empty string is a prefix of everything.
           */
          public boolean containsPrefix(String prefix)

          ...
       }
</code></pre>
    </p>
    <p class="text">
    Some hints to get you started:
    <ul class="bullet">
      <li> Start by reviewing the <code>Mnemonics</code> example.  That method lists all possible mnemonics for the input number sequence, and is a very good starting point.</li>


      <li>
        <code>listCompletions</code> consists of two recursive pieces. They require
        similar, but not identical, code. The first is almost the same as
        <code>listMnemonics</code>, which gives you a way to convert the digit sequence
        into letters. Here, though, rather than printing each mnemonic found,
        we want to pass them to the second recursive method, which will extend
        that prefix in an attempt to build words. In the first case, the
        choices for the letters are constrained by the digit-to-letter
        mapping.  In the second, what are the possible choices for letters
        that could be used to extend the sequence to built a completion?</li>

      <li>
        Be sure to take advantage of the Lexicon member function
        <code>containsPrefix</code>. This allows you check whether a sequence of
        letters is the prefix of any word contained in the lexicon. You will
        need to use this to avoid going down dead ends.</li>
    </ul>
    </p>
    <p class="text">
    Your program should first create the lexicon and then pass it, along
    with a digit sequence to your method:
    <pre>
        public static void listCompletions(String digitSequence, Lexicon lex) { ... }

        public static void main(String args[]) {
          ...
          Lexicon lexicon = new Lexicon("lexicon.dat");
          listCompletions("72547", lexicon);
          ...
        }
    </pre>
    </p>
-->

    <p class="heading" id="checkstyle">
      <strong><code>checkstyle</code> requirements</strong>:
    </p>

    <p class="text">
      For this week's lab, we will be adding one
      new <code>checkstyle</code> rule to the set of rules that we
      have used in previous weeks.  We would like you to
      include <a href="https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html">Javadoc</a>-style
      comments for each <b><code>public</code></b> method (it is OK to
      include them for <code>protected</code> and <code>private</code>
      methods as well, but it is not required). The description of the
      Javadoc
      <a href="https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#format">comment format</a> is available on the Oracle website,
      but we have replicated the important rules (for us in CS136) here:
    </p>
    <ul class="bullet">
      <li>Each line above is indented to align with the code below the comment.
      <li>The first line contains the begin-comment delimiter (<code>/**</code>).
      <li>Write the first sentence as a short summary of the method
      <li>An <code>@param</code> tag is "required" (by convention) for
      every parameter, even when the description is obvious.
      <li>The <code>@return</code> tag is required for every method
      that returns something other than <code>void</code>, even if it
      is redundant with the method description. (Whenever possible,
      find something non-redundant (ideally, more specific) to use for
      the tag comment.)
      <li>The <code>@pre</code> tag is used for preconditions, (when
      applicable)
      <li>The <code>@post</code> tag is used for postconditions (when
      applicable)
    </ul>


    <p class="text">
      In this lab, like last week, we have provided starter code
      that already contains Javadoc comments (however, we have left
      some parts for you to fill in).
      This will not always be the case in future labs, so please
      take this chance to familiarize yourself with the Javadoc format.
    </p>

    <p class="text">
      We <em>STRONGLY ENCOURAGE</em> you to run
      checkstyle early and often when developing your code,
      and try to program in a way that minimizes WARNING messages.
      The checkstyle rules that we use in this course
      are based on real-world style guides;
      internalizing good style practices will help us write more
      readable code.
    </p>

    <p class="text">
      <b>In total, checkstyle will enforce the following guidelines:</b>
    </p>

    <ul class="bullet">
      <li>
	All class variables that are not <code>final</code> must be
	declared <code>private</code> or <code>protected</code> (i.e.,
	no <code>public</code> member variables unless they are
	constants). (We don't expect this to be an issue this week.)
      </li>

      <li>
	All <code>public</code> methods must include a “Javadoc” comment
	(starts with <code>/**</code> and ends with <code>*/</code>;
	it should include descriptions of the function at the top,
	descriptions of each arguments after a <code>@param</code>
	and pre/post conditions after the <code>@pre</code>
	or <code>@post</code> tags).
      </li>
      <li>
	No methods should be longer than 30 lines (excluding whitespace
	and single-line comments).
      </li>
    </ul>

    <br><br>

    <p class="text">
      <b>To run <code>checkstyle</code>, you would type the following
      command at the terminal:</b>
    </p>

<pre><code>
          $ ./checkstyle
</code></pre>

    <p class="text">
      The <code>./</code> is peculiar to Unix: it tells the terminal
      to look for the <code>checkstyle</code> program in the current
      directory.  This command will run <code>checkstyle</code> on
      every Java program in your directory.  To
      run <code>checkstyle</code> on a specific Java file, type:
    </p>

<pre><code>
          $ ./checkstyle SomeFile.java
</code></pre>


    <p class="heading">Lab Deliverables</p>
    <p class="text">
      You (and your teammate, if you are working in a pair)
      should have a new private repository available to you on GitLab.
      Inside the repository, you should see the following files:
    </p>
    <ul class="bullet">
      <li><code>README.md</code></li>
      <li><code>Rubric.md</code></li>
      <li><code>Problems.md</code></li>
      <li><code>Recursion.java</code></li>
    </ul>
    <p class="text">
      The <code>Recursion.java</code> file contains starter code,
      and you should write all of your functions inside that file.
      <b>Since we are learning about running times and big-O analysis
	in lecture, for this lab, our <code>Problems.md</code> file will
	ask us to provide the running time (in big-O notation) for
	each method&mdash;with a brief justiﬁcation.</b>  These
	runtimes replace the typical thought questions for this week.
    </p>

    <p class="heading">Submitting Your Lab</p>
    <p class="text">
      As you complete portions of this lab,
      you should <code>commit</code> your changes
      and <code>push</code> them.
      <u>Commit early and often</u>.
      When the deadline arrives,
      we will retrieve the latest version of your code.
      If you are confident that you are done,
      please use the phrase <code>"Lab Submission"</code>
      as the commit message for your final commit.
      If you later decide that you have more edits to make,
      it is OK.
      We will look at the latest commit before the deadline.
    </p>

    <ul class="bullet">
      <li><u>Be sure to push your changes to GitLab.</u></li>
      <li><u>Verify your changes are visible on GitLab.</u>
	You should see all changes reflected in the files that you
	<code>push</code>.
	If not, go back and make sure you have both committed and pushed.
      </li>
    </ul>

    <p class="text">
      We will know that the files are yours because they are
      in <em>your</em> <code>git</code> repository. <u>Do not include
      identifying information in the code that you submit.</u> We
      grade your lab programs anonymously to avoid bias. In
      your <code>README.md</code> file, please cite any sources of
      inspiration or collaboration (e.g., conversations with
      classmates). We take the honor code very seriously, and so
      should you. Please include the statement <code>"I am the sole
      author of the work in this repository."</code> in the comments
      at the top your Java files (or "we" if you worked with a
      partner).
    </p>


    <p class="bottom">&nbsp;</p>

</body>
</html>
